---
title: VG_PostAnimator Component
keywords: component, animator, grasp, postanimator
sidebar: main_sidebar
permalink: unity_component_vgpostanimator.html
folder: mydoc
---

VG_PostAnimator is a Unity script that exemplifies how you could overwrite ("post-animate") grasp animations that are generated by VirtualGrasp.

The emphasis here that this is merely an example, and that the important thing is that it is possible to overwrite grasp animations with your own animations 
during grasping by adding a listener to the [VG_Controller.OnPostUpdate](virtualgrasp_unityapi.html#onpostupdate) event.

In this simple example script, the VR trigger button (value between 0 and 1) is used to slerp the rotation of the index finger between the current bone rotation 
(generated by VirtualGrasp) and a manually defined target rotation. 

This is a use case that you may want to follow if you want to animate a finger push while you have an object in your hand (such as when using an electric tool). Manually programming your animations will allow you to implement more interesting use cases as shown below.

```js

// VirtualGrasp/Scripts/VG_PostAnimator.cs

using UnityEngine;
using UnityEngine.XR;
using VirtualGrasp;

/** 
 * VG_PostAnimator exemplifies how you could overwrite (post-animate) grasp animations that are handled by VirtualGrasp.
 */
[LIBVIRTUALGRASP_UNITY_SCRIPT]
[HelpURL("https://docs.gleechi.com/unity_component_vgpostanimator.html")]
public class VG_PostAnimator : MonoBehaviour
{
    private Quaternion m_leftHandTargetRotation = Quaternion.Euler(14.47f, -274.42f, -348.29f);
    private Quaternion m_rightHandTargetRotation = Quaternion.Euler(14.47f, 274.42f, 348.29f);

    void Start()
    {
        VG_Controller.OnPostUpdate.AddListener(Animate);
    }

    private bool GetOtherButtonTrigger(VG_HandSide handSide, out float trigger)
    {
        // Receive the device used for this hand side, and receive the trigger value of ...
        InputDevice device = UnityEngine.XR.InputDevices.GetDeviceAtXRNode(handSide == VG_HandSide.LEFT ? XRNode.LeftHand : XRNode.RightHand);
        // ... the grip button if VG is using the trigger for grasping (or the other way around)
        return device.TryGetFeatureValue(VG_Controller.GetTriggerButton() == VG_VrButton.GRIP ? CommonUsages.trigger : CommonUsages.grip, out trigger);
    }

    public void Animate()
    {
        foreach (VG_HandStatus hand in VG_Controller.GetHands())
        {
            // Check if it is this object that is held in the hand.
            if (hand.m_selectedObject != transform || !hand.IsHolding())
                continue;

            // Receive the trigger signal of the controller and the transform of the first (0) bone of the index finger (1).
            if (GetOtherButtonTrigger(hand.m_side, out float trigger) &&
                VG_Controller.GetFingerBone(hand.m_avatarID, hand.m_side, 1, 0, out Transform currentTransform) == VG_ReturnCode.SUCCESS)
            {
                // Modify the local transform by interpolating it between the current and the target rotation.
                currentTransform.localRotation = Quaternion.Slerp(hand.m_side == VG_HandSide.LEFT ?
                    m_leftHandTargetRotation : m_rightHandTargetRotation,
                    currentTransform.localRotation,
                    trigger);
            }
        }
    }
}

````

## Use Case

The most common use case for post-animation is to create a finger animation on an articulated object, for example scissors.

The steps to achieve the manipulation on the scissors in the video:

* Make a single object that combines the two articulated parts (for scissors the two handles), we call for example **scissor**.
* Make two objects corresponding to the two articulated parts of **scissor**, we call **handle_left** and **handle_right**.
* In Unity set up the object hiearchy such that **scissor** is the parent of the two handles, and the two handles should be in a position overlapping with **scissor**.
* Make **scissor** as a VG interactable object, but deactivate mesh renderer, so it is invisible. 
* Make both **handles** non-interactable with VG, but activate mesh renderer, so they are actually visible.
* Once you have baked the objects, then only the VG interactable object **scissor** is baked, so DG is available on this object.
* Use [VG_GraspStudio](unity_component_vggraspstudio.html#grasp-studio) to create a primary grasp on **scissor** to be suitable for the initial pose for the manipulation.
* Find the position where you want to lerp the fingers when triggering the button and add them to the post animator script
* Add the specific behaviour you want in the post animator script to rotate the handles


{% include youtube.html id="SWekpa7OxHI" %}
